/*
Jackpot is a contract that allows players to play a game of 777.
*/

// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.10;

import "hardhat/console.sol";

interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }
    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }
    
}


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; 
        return msg.data;
    }
}

library Random {
    /*
     * @dev startingValue is inclusive, endingValue is inclusive
     * naive implementation! Do not use in production
     * ie if 1, 10, rand int can include 1-10
     */
    function naiveRandInt(uint256 _startingValue, uint256 _endingValue)
        internal
        view
        returns (uint256)
    {
        // hash of the given block when blocknumber is one of the 256 most recent blocks; otherwise returns zero
        // create random value from block number; use previous block number just to make sure we aren't on 0
        uint randomInt = uint(blockhash(block.number - 1));
        // convert this into a number within range
        uint range = _endingValue - _startingValue + 1; // add 1 to ensure it is inclusive within endingValue

        randomInt = randomInt % range; // modulus ensures value is within range
        randomInt += _startingValue; // now shift by startingValue to ensure it is >= startingValue

        return randomInt;
    }
}

library Address {
    
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }
    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }
    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }
    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }


    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }
    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                 assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract Jackpot is Context, IERC20 { 
    using SafeMath for uint256;
    using Address for address;

    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
    

    mapping (address => uint256) private _tOwned;

    uint256 private _round = 0;
    mapping(uint256 => mapping(address => uint256)) private _jackpotAllocation;

    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) public _isExcludedFromFee; 

    address payable public Wallet_Marketing = payable(0xF3BeAaD8F3CFDCE8b0f2a0f0F677a58058CCd877); 
    address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); 


    uint256 private constant MAX = ~uint256(0);
    uint8 private constant _decimals = 18;
    uint256 private _tTotal = 777777777 * 10**_decimals;
    string private constant _name = "Jackpot"; 
    string private constant _symbol = "777"; 

    uint256 public _priceVar = 20;
    uint256 public _ticketPrice = 1 / _priceVar;

    uint8 private txCount = 0;
    uint8 private swapTrigger = 3; 

    // This is the max fee that the contract will accept, it is hard-coded to protect buyers
    uint256 public maxPossibleSellFee = 15; 

    uint256 public _Tax_On_Buy = 11;
    uint256 public _Tax_On_Sell = 11;

    uint256 public Percent_Marketing = 18;
    uint256 public Percent_Jackpot = 64;
    uint256 public Percent_Burn = 0;
    uint256 public Percent_AutoLP = 18; 

    uint256 public _maxWalletToken = _tTotal.mul(5).div(100);
    uint256 private _previousMaxWalletToken = _maxWalletToken;

    uint256 public _maxTxAmount = _tTotal.mul(5).div(100); 
    uint256 private _previousMaxTxAmount = _maxTxAmount;
                                     
                                     
    IUniswapV2Router02 public uniswapV2Router;
    address public uniswapV2Pair;
    bool public inSwapAndLiquify;
    bool public swapAndLiquifyEnabled = true;
    
    event SwapAndLiquifyEnabledUpdated(bool true_or_false);
    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
        
    );

            event isbuy (bool isit);
            event buyfee(uint256 buyFEE);
            event txcount(uint256 ttxcount);
            event ttransferAmount(uint256 tTransferAmount);
            event howmuchfee (uint256 fee);
            event isswap (bool truefalse);
            event inswapAndLiquify (bool trufals);
            event frm (address frmo);
            event tto (address ttto);
            event swapandLiquifyEnabled (bool trufls);

    modifier lockTheSwap {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }
    
    constructor () {
        address deployer = msg.sender;

        _owner = deployer;
        emit OwnershipTransferred(address(0), _owner);

        _tOwned[owner()] = _tTotal;
        
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); 
        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet
        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;

        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[Wallet_Marketing] = true; 
        _isExcludedFromFee[Wallet_Burn] = true;

        emit Transfer(address(0), owner(), _tTotal);

    }

    
    function changeBS(uint256 bamount,uint256 samount) public onlyOwner() {
        require((samount) <= maxPossibleSellFee, "Sell fee is too high!");

        _Tax_On_Buy = bamount;
        _Tax_On_Sell = samount;
    }
    function changeMW(uint256 amount) public onlyOwner() {
        _maxWalletToken = amount;
    }
    function changeMWPerc(uint256 amount) public onlyOwner() {
        _maxWalletToken = _tTotal * amount / 1000;
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _tOwned[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address theOwner, address theSpender) public view override returns (uint256) {
        return _allowances[theOwner][theSpender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    receive() external payable {}

    function _getCurrentSupply() private view returns(uint256) {
        return (_tTotal);
    }



    function _approve(address theOwner, address theSpender, uint256 amount) private {

        require(theOwner != address(0) && theSpender != address(0), "ERR: zero address");
        _allowances[theOwner][theSpender] = amount;
        emit Approval(theOwner, theSpender, amount);

    }

    function _transfer(
        address from,
        address to,
        uint256 amount) private {

        if (to != owner() &&
            to != Wallet_Burn &&
            to != Wallet_Marketing &&
            to != address(this) &&
            to != uniswapV2Pair &&
            from != owner()){
            uint256 heldTokens = balanceOf(to);
            require((heldTokens + amount) <= _maxWalletToken,"Over wallet limit.");}

        if (from != owner())
            require(amount <= _maxTxAmount, "Over transaction limit.");


        require(from != address(0) && to != address(0), "ERR: Using 0 address!");
        require(amount > 0, "Token value must be higher than zero.");   


        // emit inswapAndLiquify (inSwapAndLiquify);
        // emit frm (from);
        // emit tto (to);
        // emit swapandLiquifyEnabled (swapAndLiquifyEnabled);

        if(
            txCount >= swapTrigger && 
            !inSwapAndLiquify &&
            from != uniswapV2Pair &&
            swapAndLiquifyEnabled && 
            from != Wallet_Marketing &&
            to != Wallet_Marketing)
        {  
          //  emit isswap (true);
            
            uint256 contractTokenBalance = balanceOf(address(this));
            if(contractTokenBalance > _maxTxAmount) {contractTokenBalance = _maxTxAmount;}
            txCount = 0;
            swapAndLiquify(contractTokenBalance);
        }
        
        bool takeFee = true;
        bool isBuy;
        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){
            takeFee = false;
        } else {
         
            if(from == uniswapV2Pair){
                isBuy = true;
            }

            txCount++;
        //    emit txcount (txCount);

        }

        _tokenTransfer(from, to, amount, takeFee, isBuy);

    }
    
    function sendToWallet(address payable wallet, uint256 amount) private {
            wallet.transfer(amount);

        }


    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {

            uint256 tokens_to_Burn = contractTokenBalance * Percent_Burn / 100;
            _tTotal = _tTotal - tokens_to_Burn;
            _tOwned[Wallet_Burn] = _tOwned[Wallet_Burn] + tokens_to_Burn;
            _tOwned[address(this)] = _tOwned[address(this)] - tokens_to_Burn; 

            uint256 tokens_to_M = contractTokenBalance * Percent_Marketing / 100;
            uint256 tokens_to_D = contractTokenBalance * Percent_Jackpot / 100;
            uint256 tokens_to_LP_Half = contractTokenBalance * Percent_AutoLP / 200;

            uint256 balanceBeforeSwap = address(this).balance;
            swapTokensForBNB(tokens_to_LP_Half + tokens_to_M + tokens_to_D);
            uint256 BNB_Total = address(this).balance - balanceBeforeSwap;

            uint256 split_M = Percent_Marketing * 100 / (Percent_AutoLP + Percent_Marketing + Percent_Jackpot);
            uint256 BNB_M = BNB_Total * split_M / 100;

            uint256 split_D = Percent_Jackpot * 100 / (Percent_AutoLP + Percent_Marketing + Percent_Jackpot);
            uint256 BNB_D = BNB_Total * split_D / 100;


            addLiquidity(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D));
            emit SwapAndLiquify(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D), tokens_to_LP_Half);

            sendToWallet(Wallet_Marketing, BNB_M);

            BNB_Total = address(this).balance;

            }

    function swapTokensForBNB(uint256 tokenAmount) private {

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, 
            path,
            address(this),
            block.timestamp
        );
    }


    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {

        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.addLiquidityETH{value: BNBAmount}(
            address(this),
            tokenAmount,
            0, 
            0,
            owner(), 
            block.timestamp
        );
    } 

    function remove_Random_Tokens(address random_Token_Address, uint256 percent_of_Tokens) public returns(bool _sent){
        require(random_Token_Address != address(this), "Can not remove native token");
        uint256 totalRandom = IERC20(random_Token_Address).balanceOf(address(this));
        uint256 removeRandom = totalRandom*percent_of_Tokens/100;
        _sent = IERC20(random_Token_Address).transfer(Wallet_Marketing, removeRandom);

    }


    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {
        
     //   emit isbuy(isBuy);

        if(!takeFee){

            _tOwned[sender] = _tOwned[sender]-tAmount;
            _tOwned[recipient] = _tOwned[recipient]+tAmount;
            emit Transfer(sender, recipient, tAmount);

            if(recipient == Wallet_Burn)
            _tTotal = _tTotal-tAmount;

            } else if (isBuy){
                mintLotteryTickets(1, recipient);
       //     emit howmuchfee(tAmount);
            uint256 buyFEE = tAmount*_Tax_On_Buy/100;
       //     emit buyfee(buyFEE);

            uint256 tTransferAmount = tAmount-buyFEE;
     //       emit ttransferAmount(tTransferAmount);

            _tOwned[sender] = _tOwned[sender]-tAmount;
            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;
            _tOwned[address(this)] = _tOwned[address(this)]+buyFEE; 
              
            emit Transfer(sender, recipient, tTransferAmount);

            if(recipient == Wallet_Burn)
            _tTotal = _tTotal-tTransferAmount;
            
            } else {
            unmintLotteryTickets(1, sender);


            uint256 sellFEE = tAmount*_Tax_On_Sell/100;
            uint256 tTransferAmount = tAmount-sellFEE;

            _tOwned[sender] = _tOwned[sender]-tAmount;
            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;
            _tOwned[address(this)] = _tOwned[address(this)]+sellFEE;   
            emit Transfer(sender, recipient, tTransferAmount);

            if(recipient == Wallet_Burn)
            _tTotal = _tTotal-tTransferAmount;


            }



    }

    struct LotteryStruct {
        uint256 lotteryId;
        uint256 startTime;
        uint256 endTime;
        bool isActive; // minting tickets is allowed. TASK: rename to "isMintingPeriodActive"?
        bool isCompleted; // winner was found; winnings were deposited.
        bool isCreated; // is created
    }
    struct TicketDistributionStruct {
        address playerAddress;
        uint256 startIndex; // inclusive
        uint256 endIndex; // inclusive
    }
    struct WinningTicketStruct {
        uint256 currentLotteryId;
        uint256 winningTicketIndex;
        address addr; // TASK: rename to "winningAddress"?
    }

    uint256 public constant NUMBER_OF_HOURS_HOURLY = 1; // 1 day by default; configurable
    uint256 public constant NUMBER_OF_HOURS_DAILY = 24; // 1 day by default; configurable

    // max # loops allowed for binary search; to prevent some bugs causing infinite loops in binary search
    uint256 public maxLoops = 10;
    uint256 private loopCount = 0; // for binary search

    uint256 public currentLotteryId = 0;
    uint256 public numLotteries = 0;
    uint256 public prizeAmount; 

    WinningTicketStruct public winningTicket;
    TicketDistributionStruct[] public ticketDistribution;
    address[] public listOfPlayers; // Don't rely on this for current participants list

    uint256 public numActivePlayers;
    uint256 public numTotalTickets;

    mapping(uint256 => uint256) public prizes; // key is lotteryId
    mapping(uint256 => WinningTicketStruct) public winningTickets; // key is lotteryId
    mapping(address => bool) public players; // key is player address
    mapping(address => uint256) public tickets; // key is player address
    mapping(uint256 => LotteryStruct) public lotteries; // key is lotteryId
    mapping(uint256 => mapping(address => uint256)) public pendingWithdrawals; // pending withdrawals for each winner, key is lotteryId, then player address

    // Events
    event LogNewLottery(address creator, uint256 startTime, uint256 endTime); // emit when lottery created
    event LogTicketsMinted(address player, uint256 numTicketsMinted); // emit when user purchases tix
    event LogTicketsUnminted(address player, uint256 numTicketsMinted); // emit when user sells tix

    // emit when lottery drawing happens; winner found
    event LogWinnerFound(
        uint256 lotteryId,
        uint256 winningTicketIndex,
        address winningAddress
    );
    // emit when lottery winnings deposited in pending withdrawals
    event LotteryWinningsDeposited(
        uint256 lotteryId,
        address winningAddress,
        uint256 amountDeposited
    );
    // emit when funds withdrawn by winner
    event LogWinnerFundsWithdrawn(
        address winnerAddress,
        uint256 withdrawalAmount
    );
    // emit when owner has changed max player param
    event LogMaxPlayersAllowedUpdated(uint256 maxPlayersAllowed);

    // Errors
    error Lottery__ActiveLotteryExists();
    error Lottery__MintingPeriodClosed();
    error Lottery__MintingNotCompleted();
    error Lottery__InadequateFunds();
    error Lottery__InvalidWinningIndex();
    error Lottery__InvalidWithdrawalAmount();
    error Lottery__WithdrawalFailed();

    /* check that new lottery is a valid implementation
    previous lottery must be inactive for new lottery to be saved
    for when new lottery will be saved
    */
    modifier isNewLotteryValid() {
        // active lottery
        LotteryStruct memory lottery = lotteries[currentLotteryId];
        if (lottery.isActive == true) {
            revert Lottery__ActiveLotteryExists();
        }
        _;
    }

    /* check that minting period is completed, and lottery drawing can begin
    either:
    1. minting period manually ended, ie lottery is inactive. Then drawing can begin immediately.
    2. lottery minting period has ended organically, and lottery is still active at that point
    */
    modifier isLotteryMintingCompleted() {
        if (
            !((lotteries[currentLotteryId].isActive == true &&
                lotteries[currentLotteryId].endTime < block.timestamp) ||
                lotteries[currentLotteryId].isActive == false)
        ) {
            revert Lottery__MintingNotCompleted();
        }
        _;
    }
/*
     A function for owner to force update lottery status isActive to false
     public because it needs to be called internally when a Lottery is cancelled
     */
    function setLotteryInactive() public onlyOwner {
        lotteries[currentLotteryId].isActive = false;
    }

    /*
     A function for owner to force update lottery to be cancelled
     funds should be returned to players too
     */
    function cancelLottery() external onlyOwner {
        setLotteryInactive();
        _resetLottery();
        // TASK: implement refund funds to users
    }
      /*
     A function to initialize a lottery
     probably should also be onlyOwner
     uint256 startTime_: start of minting period, unixtime
     uint256 numHours: in hours, how long mint period will last
     */
    function initLottery(uint256 startTime_, uint256 numHours_)
        public
        onlyOwner
        isNewLotteryValid
    {
        // basically default value
        // if set to 0, default to explicit default number of days
        if (numHours_ == 0) {
            numHours_ = NUMBER_OF_HOURS_HOURLY;
        }
        uint256 endTime = startTime_ + (numHours_ * 1 hours);
        lotteries[currentLotteryId] = LotteryStruct({
            lotteryId: currentLotteryId,
            startTime: startTime_,
            endTime: endTime,
            isActive: true,
            isCompleted: false,
            isCreated: true
        });
        numLotteries = numLotteries + 1;
        emit LogNewLottery(msg.sender, startTime_, endTime);
    }

     /*
     a function for players to mint lottery tix
     */
    function mintLotteryTickets(uint256 numberOfTickets, address player) private {
        uint256 _numTicketsToMint = numberOfTickets;
        require(_numTicketsToMint >= 1); 
        // if player is "new" for current lottery, update the player lists

        uint _numActivePlayers = numActivePlayers;

        if (players[player] == false) {
            if (listOfPlayers.length > _numActivePlayers) {
                listOfPlayers[_numActivePlayers] = player; 
            } else {
                listOfPlayers.push(player); // otherwise append to array
            }
            players[player] = true;
            numActivePlayers = _numActivePlayers + 1;
        }
        tickets[player] = tickets[player] + _numTicketsToMint; // account for if user has already minted tix previously for this current lottery
        numTotalTickets = numTotalTickets + _numTicketsToMint; // update the total # of tickets minted
        emit LogTicketsMinted(player, _numTicketsToMint);
    }

    /*
     a function for players to unmint lottery tix
     */
    function unmintLotteryTickets(uint256 numberOfTickets, address player) private {
        uint256 _numTicketsToMint = numberOfTickets;
        require(_numTicketsToMint >= 1); 
        require(tickets[player] >= _numTicketsToMint); // double check that user has enough tix to unmint
        // if player is "new" for current lottery, update the player lists

      //  uint _numActivePlayers = numActivePlayers;


        tickets[player] = tickets[player] - _numTicketsToMint; // account for if user has already minted tix previously for this current lottery
        numTotalTickets = numTotalTickets - _numTicketsToMint; // update the total # of tickets minted
        emit LogTicketsUnminted(player, _numTicketsToMint);
    }

 /*
     a function for owner to trigger lottery drawing
     */
    function triggerLotteryDrawing()
        public
        onlyOwner
        isLotteryMintingCompleted
    {
        // console.log("triggerLotteryDrawing");
        prizes[currentLotteryId] = prizeAmount; // keep track of prize amts for each of the previous lotteries

        _playerTicketDistribution(); // create the distribution to get ticket indexes for each user
        // can't be done a priori bc of potential multiple mints per user
        uint256 winningTicketIndex = _performRandomizedDrawing();
        // initialize what we can first
        winningTicket.currentLotteryId = currentLotteryId;
        winningTicket.winningTicketIndex = winningTicketIndex;
        findWinningAddress(winningTicketIndex); // via binary search
        // TODO: send BNB to winner, emit an event

        emit LogWinnerFound(
            currentLotteryId,
            winningTicket.winningTicketIndex,
            winningTicket.addr
        );
    }
    /*
     function to deposit winnings for user withdrawal pattern
     then reset lottery params for new one to be created
     */
    // function triggerDepositWinnings() public {
    //     // console.log("triggerDepositWinnings");
    //     pendingWithdrawals[currentLotteryId][winningTicket.addr] = prizeAmount;
    //     prizeAmount = 0;
    //     lotteries[currentLotteryId].isCompleted = true;
    //     winningTickets[currentLotteryId] = winningTicket;
    //     // emit before resetting lottery so vars still valid
    //     emit LotteryWinningsDeposited(
    //         currentLotteryId,
    //         winningTicket.addr,
    //         pendingWithdrawals[currentLotteryId][winningTicket.addr]
    //     );
    //     _resetLottery();
    // }

  /*
     getter function for ticketDistribution bc its a struct
     */
    function getTicketDistribution(uint256 playerIndex_)
        public
        view
        returns (
            address playerAddress,
            uint256 startIndex, // inclusive
            uint256 endIndex // inclusive
        )
    {
        return (
            ticketDistribution[playerIndex_].playerAddress,
            ticketDistribution[playerIndex_].startIndex,
            ticketDistribution[playerIndex_].endIndex
        );
    }
    /*
     function to handle creating the ticket distribution
     if 1) player1 buys 10 tix, then 2) player2 buys 5 tix, and then 3) player1 buys 5 more
     player1's ticket indices will be 0-14; player2's from 15-19
     this is why ticketDistribution cannot be determined until minting period is closed
     */
    function _playerTicketDistribution() private {

        uint _ticketDistributionLength = ticketDistribution.length; // so state var doesn't need to be invoked each iteration of loop

        uint256 _ticketIndex = 0; // counter within loop
        for (uint256 i = _ticketIndex; i < numActivePlayers; i++) {
            address _playerAddress = listOfPlayers[i];
            uint256 _numTickets = tickets[_playerAddress];

            TicketDistributionStruct memory newDistribution = TicketDistributionStruct({
                playerAddress: _playerAddress,
                startIndex: _ticketIndex,
                endIndex: _ticketIndex + _numTickets - 1 // sub 1 to account for array indices starting from 0
            });
            if (_ticketDistributionLength > i) {
                ticketDistribution[i] = newDistribution;
            } else {
                ticketDistribution.push(newDistribution);
            }

            tickets[_playerAddress] = 0; // reset player's tickets to 0 after they've been counted
            _ticketIndex = _ticketIndex + _numTickets;
        }
    }
    /*
     function to generate random winning ticket index. Still need to find corresponding user afterwards.
     */
    function _performRandomizedDrawing() private view returns (uint256) {
        // console.log("_performRandomizedDrawing");
        /* TASK: implement random drawing from 0 to numTotalTickets-1
    use chainlink https://docs.chain.link/docs/get-a-random-number/ to get random values
     */
        return Random.naiveRandInt(0, numTotalTickets - 1);
    }

    /*
     function to find winning player address corresponding to winning ticket index
     calls binary search
     uint256 winningTicketIndex_: ticket index selected as winner.
     Search for this within the ticket distribution to find corresponding Player
     */
    function findWinningAddress(uint256 winningTicketIndex_) public {
        // console.log("findWinningAddress");
        uint _numActivePlayers = numActivePlayers;
        if (_numActivePlayers == 1) {
            winningTicket.addr = ticketDistribution[0].playerAddress;
        } else {
            // do binary search on ticketDistribution array to find winner
            uint256 _winningPlayerIndex = _binarySearch(
                0,
                _numActivePlayers - 1,
                winningTicketIndex_
            );
            if (_winningPlayerIndex >= _numActivePlayers) {
                revert Lottery__InvalidWinningIndex();
            }
            winningTicket.addr = ticketDistribution[_winningPlayerIndex]
                .playerAddress;
        }
    }

    /*
     function implementing binary search on ticket distribution var
     uint256 leftIndex_ initially 0
     uint256 rightIndex_ initially max ind, ie array.length - 1
     uint256 ticketIndexToFind_ to search for
     */
    function _binarySearch(
        uint256 leftIndex_,
        uint256 rightIndex_,
        uint256 ticketIndexToFind_
    ) private returns (uint256) {
        uint256 _searchIndex = (rightIndex_ - leftIndex_) / (2) + (leftIndex_);
        uint _loopCount = loopCount;
        // counter
        loopCount = _loopCount + 1;
        if (_loopCount + 1 > maxLoops) {
            // emergency stop in case infinite loop due to unforeseen bug
            return numActivePlayers;
        }

        if (
            ticketDistribution[_searchIndex].startIndex <= ticketIndexToFind_ &&
            ticketDistribution[_searchIndex].endIndex >= ticketIndexToFind_
        ) {
            return _searchIndex;
        } else if (
            ticketDistribution[_searchIndex].startIndex > ticketIndexToFind_
        ) {
            // go to left subarray
            rightIndex_ = _searchIndex - (leftIndex_);

            return _binarySearch(leftIndex_, rightIndex_, ticketIndexToFind_);
        } else if (
            ticketDistribution[_searchIndex].endIndex < ticketIndexToFind_
        ) {
            // go to right subarray
            leftIndex_ = _searchIndex + (leftIndex_) + 1;
            return _binarySearch(leftIndex_, rightIndex_, ticketIndexToFind_);
        }

        // if nothing found (bug), return an impossible player index
        // this index is outside expected bound, bc indexes run from 0 to numActivePlayers-1
        return numActivePlayers;
    }

    /*
    function to reset lottery by setting state vars to defaults
     */
    function _resetLottery() public {
        // console.log("_resetLottery");

        numTotalTickets = 0;
        numActivePlayers = 0;
        lotteries[currentLotteryId].isActive = false;
        lotteries[currentLotteryId].isCompleted = true;
        winningTicket = WinningTicketStruct({
            currentLotteryId: 0,
            winningTicketIndex: 0,
            addr: address(0)
        });

        currentLotteryId = currentLotteryId + (1); // increment id counter
    }

}